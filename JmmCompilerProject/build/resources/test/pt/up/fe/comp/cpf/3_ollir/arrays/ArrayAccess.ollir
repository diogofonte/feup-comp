import ioPlus;
ArrayAccess extends Object {

.method public foo(a.array.i32).i32 {

    tmp0.i32 :=.i32 a.array.i32[0.i32].i32;
    result.i32 :=.i32 tmp0.i32;
    tmp1.i32 :=.i32 a.array.i32[1.i32].i32;
    tmp2.i32 :=.i32 a.array.i32[2.i32].i32;
    tmp3.i32 :=.i32 tmp1.i32 +.i32 tmp2.i32;
    result.i32 :=.i32 tmp3.i32;
    tmp4.i32 :=.i32 a.array.i32[3.i32].i32;
    tmp5.i32 :=.i32 result.i32 +.i32 tmp4.i32;
    result.i32 :=.i32 tmp5.i32;
    tmp6.i32 :=.i32 a.array.i32[4.i32].i32;
    tmp7.i32 :=.i32 1.i32 +.i32 tmp6.i32;

    result.i32 :=.i32 t18.i32;
    t21.i32 :=.i32 0.i32;
    a[t21.i32].i32 :=.i32 1.i32;
    t22.i32 :=.i32 1.i32;
    a[t22.i32].i32 :=.i32 2.i32;
    t23.i32 :=.i32 2.i32;
    a[t23.i32].i32 :=.i32 3.i32;
    t24.i32 :=.i32 3.i32;
    a[t24.i32].i32 :=.i32 4.i32;
	t25.i32 :=.i32 4.i32;
	a[t25.i32].i32 :=.i32 5.i32;

    ret.i32 result.i32;
}

.construct ArrayAccess().V {
invokespecial(this, "").V;
}
}